---
layout: default
title: "极客时间《高并发系统设计40问》阅读笔记：数据库/缓存/消息队列/分布式服务"
author: 李佶澳
date: "2021-10-08 15:29:20 +0800"
last_modified_at: "2021-10-08 15:29:20 +0800"
categories:  编程
cover:
tags: 阅读笔记 系统设计
keywords: 高并发系统,数据库,缓存,消息队列,分布式服务
description:  涉及的内容比较多（数据库/缓存/消息队列/分布式服务），有点浮于表面，不如分别阅读每个方向的专栏
---

## 本篇目录

* auto-gen TOC:
{:toc}

## 说明

这个专栏比较一般，涉及的内容比较多（数据库/缓存/消息队列/分布式服务），但是蜻蜓点水，有点浮于表面，不如分别阅读[每个方向的专栏](/geekclass/)。

## 基本方法

* 水平扩展
* 缓存
* 异步

阿里巴巴的系统分层方法：

![阿里巴巴系统分层规范]({{site.article}}/ali-arch-layer.webp)

## 数据库优化

数据库优化方法：

1. 使用数据库连接池，避免每次新建连接
2. 主从复制，读写分离，主从延迟处理方法
3. 数据库分库（垂直拆分）：将多个表拆分到多个数据库中
4. 数据库分表（水平拆分）：将一个表拆分到多个数据库中 
5. 使用NoSQL方法：1. 具被水平扩展能力，mongo/es等 2. 如果需要模糊查询，使用基于倒排索引的 ES

主从延迟处理方法：
1. 编码设计时，通过数据冗余的方式避免写入后立即查询
2. 写数据库时，同步写入缓存 
3. 直连主库

分库分表后注意事项：
1. 查询需要带有分区字段，否则会查询所有数据库
2. 无法跨库 join
3. 聚合查询性能变差，例如count() 
4. 不能用自增ID作为全局唯一主键

全局唯一主键获取方法：

1. 使用 Snowflake 算法生成
2. uuid 的问题：不是单调递增的

聚簇索引与基于LSM树的存储引擎：
1. 聚簇索引中，索引和数据同时存储，数据插入更新导致随机IO，页分裂时需要移动数据
2. LSM树牺牲读性能提高写性能：用多个有序的 SSTable 文件存储，写入时先写入 MemTable，然后择机生成/合并 SSTable
 
## 缓存优化

各类操作耗时：ssd磁盘读取耗时是内存读取耗时的1万倍。

![操作耗时]({{ site.article}}/latency.webp)

缓存会引入数据不一致的问题。

Cache Aside 策略：
1. 读取时，如果缓存中存在使用缓存数据，否则查询数据库并更新缓存
2. 更新时，先更新数据库，然后删除缓存
3. 如果并发操作A在B进行更新前读取了旧数据，B删除缓存后，A才开始更新缓存，这时会出现数据不一致。
4. 一种解决方法是「延迟双删」：B更新数据库前删除缓存，更新数据库后等等一段实际，再删一次缓存。（这种方法可以降低数据不一致的概率，但不能完全避免）

Write Through 策略：
1. 更新时，缓存中有对应数据，直接更新缓存，然后缓存组件负责将更新同步到数据库
2. 更新时，缓存中无对应数据，方式一（Write allocate），写入缓存，缓存组件负责同步到数据库，方式二（No-Write alocate），直接更新数据库

Read Through  策略：
1. 读取时，如果缓存中不存在对应数据，由缓存组件负责从数据库中加载

缓存穿透/缓存击穿的处理方法：
1. 回种空值，对应数据不存在时，在缓存中写入空值，这种方式会增加缓存空间的使用量（大量空值数据）
2. 使用布隆过滤器，将所有存在的ID经过hash、取模后映射到二进制bit数组中，查询时先用布隆过滤器判断是否存在。布隆过滤器判定不存在则一定不存在，但是不存在的记录有可能被判定为存在

极热缓存失效后出现大量穿透的问题的处理：
1. 设置一个简单的分布式锁（例如 redis 的 setnx），穿透到数据库之前，先获取分布式锁，避免大量并发请求同时穿透数据库

## 消息队列

这章讲的很一般，没有什么实质性内容，建议阅读另一个专栏:  [李玥《消息队列高手课》](/geekclass/#李玥消息队列高手课)

## 分布式服务

这部分也泛泛而谈

## 参考

1. [李佶澳的博客][1]

[1]: https://www.lijiaocn.com "李佶澳的博客"
